from datetime import date, datetime  # noqa: F401

from typing import List, Dict  # noqa: F401

from improving_agent.models.any_type import AnyType
from improving_agent.models.base_model import Model
from improving_agent import util

class AttributeConstraint(Model):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.
    """

    def __init__(self, id=None, name=None, _not=False, operator=None, value=None, unit_id=None, unit_name=None):  # noqa: E501
        """AttributeConstraint - a model defined in OpenAPI

        :param id: The id of this AttributeConstraint.  # noqa: E501
        :type id: str
        :param name: The name of this AttributeConstraint.  # noqa: E501
        :type name: str
        :param _not: The _not of this AttributeConstraint.  # noqa: E501
        :type _not: bool
        :param operator: The operator of this AttributeConstraint.  # noqa: E501
        :type operator: str
        :param value: The value of this AttributeConstraint.  # noqa: E501
        :type value: object
        :param unit_id: The unit_id of this AttributeConstraint.  # noqa: E501
        :type unit_id: object
        :param unit_name: The unit_name of this AttributeConstraint.  # noqa: E501
        :type unit_name: object
        """
        self.openapi_types = {
            'id': str,
            'name': str,
            '_not': bool,
            'operator': str,
            'value': AnyType,
            'unit_id': AnyType,
            'unit_name': AnyType
        }

        self.attribute_map = {
            'id': 'id',
            'name': 'name',
            '_not': 'not',
            'operator': 'operator',
            'value': 'value',
            'unit_id': 'unit_id',
            'unit_name': 'unit_name'
        }

        self._id = id
        self._name = name
        self.__not = _not
        self._operator = operator
        self._value = value
        self._unit_id = unit_id
        self._unit_name = unit_name

    @classmethod
    def from_dict(cls, dikt) -> 'AttributeConstraint':
        """Returns the dict as a model

        :param dikt: A dict.
        :type: dict
        :return: The AttributeConstraint of this AttributeConstraint.  # noqa: E501
        :rtype: AttributeConstraint
        """
        return util.deserialize_model(dikt, cls)

    @property
    def id(self) -> str:
        """Gets the id of this AttributeConstraint.


        :return: The id of this AttributeConstraint.
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id: str):
        """Sets the id of this AttributeConstraint.


        :param id: The id of this AttributeConstraint.
        :type id: str
        """
        if id is None:
            raise ValueError("Invalid value for `id`, must not be `None`")  # noqa: E501

        self._id = id

    @property
    def name(self) -> str:
        """Gets the name of this AttributeConstraint.

        Human-readable name or label for the constraint concept. If appropriate, it SHOULD be the term name of the CURIE used as the 'id'. This is redundant but required for human readability.  # noqa: E501

        :return: The name of this AttributeConstraint.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name: str):
        """Sets the name of this AttributeConstraint.

        Human-readable name or label for the constraint concept. If appropriate, it SHOULD be the term name of the CURIE used as the 'id'. This is redundant but required for human readability.  # noqa: E501

        :param name: The name of this AttributeConstraint.
        :type name: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501

        self._name = name

    @property
    def _not(self) -> bool:
        """Gets the _not of this AttributeConstraint.


        :return: The _not of this AttributeConstraint.
        :rtype: bool
        """
        return self.__not

    @_not.setter
    def _not(self, _not: bool):
        """Sets the _not of this AttributeConstraint.


        :param _not: The _not of this AttributeConstraint.
        :type _not: bool
        """

        self.__not = _not

    @property
    def operator(self) -> str:
        """Gets the operator of this AttributeConstraint.

        Relationship between the database value and the constraint value for the specified id. The operators ==, >, and < mean is equal to, is greater than, and is less than, respectively. The 'matches' operator indicates that the value is a regular expression to be evaluated. If value is a list type, then at least one evaluation must be true (equivalent to OR). This means that the == operator with a list acts like a SQL 'IN' clause. If the value of the compared attribute is a list, then comparisons are performed between each of the constraint values and each of the attribute values, and any one true evaluation counts as an overall true (e.g., [1,2,3] == [6,7,2] is true). The == operator is therefore a broad interpretation of inclusion. The '===' operator requires that the constraint value and the attribute value be the same data type, length, content, and order (e.g. only [1,2,3] === [1,2,3]). The 'not' property negates the operator such that not and == means 'not equal to' (or 'not in' for a list), and not > means <=, and not < means >=, not matches means does not match, and not === means the match between the constraint and attribute values are not exact. The '==' operator SHOULD NOT be used in a manner that describes an \"is a\" subclass relationship for the parent QNode.  # noqa: E501

        :return: The operator of this AttributeConstraint.
        :rtype: str
        """
        return self._operator

    @operator.setter
    def operator(self, operator: str):
        """Sets the operator of this AttributeConstraint.

        Relationship between the database value and the constraint value for the specified id. The operators ==, >, and < mean is equal to, is greater than, and is less than, respectively. The 'matches' operator indicates that the value is a regular expression to be evaluated. If value is a list type, then at least one evaluation must be true (equivalent to OR). This means that the == operator with a list acts like a SQL 'IN' clause. If the value of the compared attribute is a list, then comparisons are performed between each of the constraint values and each of the attribute values, and any one true evaluation counts as an overall true (e.g., [1,2,3] == [6,7,2] is true). The == operator is therefore a broad interpretation of inclusion. The '===' operator requires that the constraint value and the attribute value be the same data type, length, content, and order (e.g. only [1,2,3] === [1,2,3]). The 'not' property negates the operator such that not and == means 'not equal to' (or 'not in' for a list), and not > means <=, and not < means >=, not matches means does not match, and not === means the match between the constraint and attribute values are not exact. The '==' operator SHOULD NOT be used in a manner that describes an \"is a\" subclass relationship for the parent QNode.  # noqa: E501

        :param operator: The operator of this AttributeConstraint.
        :type operator: str
        """
        allowed_values = ["==", ">", "<", "matches", "==="]  # noqa: E501
        if operator not in allowed_values:
            raise ValueError(
                "Invalid value for `operator` ({0}), must be one of {1}"
                .format(operator, allowed_values)
            )

        self._operator = operator

    @property
    def value(self) -> AnyType:
        """Gets the value of this AttributeConstraint.

        Value of the attribute. May be any data type, including a list. If the value is a list and there are multiple items, at least one comparison must be true (equivalent to OR) unless the '===' operator is used. If 'value' is of data type 'object', the keys of the object MAY be treated as a list. A 'list' data type paired with the '>' or '<' operators will encode extraneous comparisons, but this is permitted as it is in SQL and other languages.  # noqa: E501

        :return: The value of this AttributeConstraint.
        :rtype: AnyType
        """
        return self._value

    @value.setter
    def value(self, value: AnyType):
        """Sets the value of this AttributeConstraint.

        Value of the attribute. May be any data type, including a list. If the value is a list and there are multiple items, at least one comparison must be true (equivalent to OR) unless the '===' operator is used. If 'value' is of data type 'object', the keys of the object MAY be treated as a list. A 'list' data type paired with the '>' or '<' operators will encode extraneous comparisons, but this is permitted as it is in SQL and other languages.  # noqa: E501

        :param value: The value of this AttributeConstraint.
        :type value: AnyType
        """
        if value is None:
            raise ValueError("Invalid value for `value`, must not be `None`")  # noqa: E501

        self._value = value

    @property
    def unit_id(self) -> AnyType:
        """Gets the unit_id of this AttributeConstraint.

        CURIE of the units of the value or list of values in the 'value' property. The Units of Measurement Ontology (UO) should be used if possible. The unit_id MUST be provided for (lists of) numerical values that correspond to a quantity that has units.  # noqa: E501

        :return: The unit_id of this AttributeConstraint.
        :rtype: AnyType
        """
        return self._unit_id

    @unit_id.setter
    def unit_id(self, unit_id: AnyType):
        """Sets the unit_id of this AttributeConstraint.

        CURIE of the units of the value or list of values in the 'value' property. The Units of Measurement Ontology (UO) should be used if possible. The unit_id MUST be provided for (lists of) numerical values that correspond to a quantity that has units.  # noqa: E501

        :param unit_id: The unit_id of this AttributeConstraint.
        :type unit_id: AnyType
        """

        self._unit_id = unit_id

    @property
    def unit_name(self) -> AnyType:
        """Gets the unit_name of this AttributeConstraint.

        Term name that is associated with the CURIE of the units of the value or list of values in the 'value' property. The Units of Measurement Ontology (UO) SHOULD be used if possible. This property SHOULD be provided if a unit_id is provided. This is redundant but recommended for human readability.  # noqa: E501

        :return: The unit_name of this AttributeConstraint.
        :rtype: AnyType
        """
        return self._unit_name

    @unit_name.setter
    def unit_name(self, unit_name: AnyType):
        """Sets the unit_name of this AttributeConstraint.

        Term name that is associated with the CURIE of the units of the value or list of values in the 'value' property. The Units of Measurement Ontology (UO) SHOULD be used if possible. This property SHOULD be provided if a unit_id is provided. This is redundant but recommended for human readability.  # noqa: E501

        :param unit_name: The unit_name of this AttributeConstraint.
        :type unit_name: AnyType
        """

        self._unit_name = unit_name
